// DP = Dynamic plan, 동적 계획법
// N / 2 => 숫자를 절반으로 줄임
// N / 3 => 숫자를 1/3으로 줄임

const input = require("fs").readFileSync("/dev/stdin").toString().trim();

// 0번 index부터 input까지 0으로 초기화된 배열 생성
const dp = Array(parseInt(input, 10) + 1).fill(0);

for (let i = 2; i <= input; i++) {
  dp[i] = dp[i - 1] + 1;
  if (i % 2 === 0) dp[i] = Math.min(dp[i], dp[i / 2] + 1);
  if (i % 3 === 0) dp[i] = Math.min(dp[i], dp[i / 3] + 1);
}

console.log(dp[input]);

/**
 * 🧠 DP 핵심 개념 정리 (백준_1463_1로 만들기)

1. dp[i]의 의미
  - 숫자 i를 1로 만들기 위한 최소 연산 횟수
  - i는 1로 만들기 위한 숫자

2. for문이 i = 2부터 시작하는 이유
  - dp[1] = 0 (이미 1이므로 연산 필요 없음)
  - dp[2]부터는 최소 한 번 이상의 연산이 필요

3. for문 범위가 i <= input 인 이유
  - 우리가 구하려는 정답은 dp[input]이므로
  - dp[2]부터 dp[input]까지 전부 계산해야 정답에 도달

4. dp[i - 1] + 1을 먼저 계산하는 이유
  - 언제나 가능한 연산(-1)이므로, 일단 기본값으로 저장
  - 이후 /2 또는 /3 가능한 경우 더 나은 선택이면 갱신

5. Math.min 함수의 동작 방식
  - dp[i]를 매번 최신 최소값으로 갱신하는 방식
  - 마지막 조건만 남는 게 아니라, 항상 작은 값이 살아남음

6. /2 또는 /3 연산의 의미
  - 숫자를 줄이는 동작 (예: /2는 50% 줄이기)
  - 나머지(%)는 조건 확인용, 몫(/)은 실제로 줄이는 연산

7. /2 또는 /3의 순서가 뒤에 있는 이유
  - -1은 무조건 가능하므로 일단 먼저 처리하고,
  - /2, /3은 가능할 경우 최소값을 갱신하는 방식

8. 숫자를 줄이는 연산은 '몫'을 이용
  - 예: 6 / 2 = 3 → N이 3으로 바뀌는 것
  - 남는 나머지 0은 조건 확인용일 뿐, 값이 0이 되는 게 아님

9. map(parseInt)의 주의점
  - map(parseInt)는 의도대로 동작하지 않음
  - 이유: map은 (value, index)를 넘기고, parseInt는 (string, radix)를 받기 때문
  - 해결: map(v => parseInt(v, 10))처럼 명시적으로 사용해야 함
 */
